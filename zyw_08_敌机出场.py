# 目标，１．使用定时器添加敌机，设计Enemy类
pass
# 使用定时器添加敌机
"""
在pygame中可以使用　pygame.time.set_timer()来添加定时器
所谓定时器，就是每隔一段时间，去执行一些操作
语法：
set_timer(eventid,milliseconds) ->None
set_timer可以创建一个事件
１．可以在游戏循环的事件监听方法中捕获到该事件
２．第１个参数 --事件代号　需要基于常量　pygame.USEREVENT来指定
    USEREVENT是一个整数，再增加的事件可以使用USEREVENT　+ 1指定，依次类推
３．第２个参数是　事件触发间隔　的　毫秒值（１秒　＝　１０００毫秒）

定时器事件的监听
１．通过pygame.event.get()可以获取当前时刻所有的事件列表
２．遍历列表并且判断event.type是否等于eventid。如果相等，表示定时器事件发生

"""

# 定义并监听创建敌机的定时器事件
"""
pygame的定时器使用套路十分固定[定义常量] => [设置事件] => [监听事件]
１．定义定时器常量　--eventid
２．在初始化方法中，调用set_timer方法设置定时器事件
３．在游戏循环中，监听定时器事件

１．定义事件
在plane_sprites.py的顶部　定义事件常量


"""

# Enemy类设计分析与创建
"""
需求：
１．游戏启动后，每隔一秒会出现一架敌机
２．每架敌机　向屏幕下方飞行，飞行速度各不相同
３．每架敌机出现的水平位置也不尽相同
４．当敌机从屏幕下方飞出，不会在飞回到屏幕中
Enemy类（继承自GameSprites）
方法：__init__方法，update 方法
初始化方法：
    指定敌机图片
    随机敌机的初始位置和初始速度
重写update()方法
    判断是否废除屏幕，如果是，从精灵组中删除
    
"""

# 创建敌机
"""
１．在__create_sprites,添加精灵组
    敌机是定时被创建的，因此在初始化方法中，不需要创建敌机
２．在__event_handler，创建敌机，并且添加到精灵组
    调用精灵组的add方法可以想精灵组中添加精灵
3.在__update_sprites，让敌机精灵组调用update和draw方法



"""

# 随机敌机位置和速度
"""
２．修改plane_sprites.py增加random的导入
import random
3.指定敌机的随机出事位置，不仅要指定x（随机出现）还要指定y（在最上方出现）
指定y  --使用pygame.Rect提供的bottom属性，在指定敌机初始位置时，会比较方便
    bottom = y + height
    y = bottom - height
指定x　--要用屏幕宽度－飞机宽度，这才是飞机随机x的范围，而不是整个屏幕的范围
"""

# 移出屏幕后销毁敌机
"""
敌机移出屏幕后，如果没有撞到英雄，敌机的历史使命已经终结
需要从敌机组删除，否则会造成内存浪费

检测敌机被销毁
    __del__内置方法会在对象被销毁钱调用，在开发时，可以用于判断对象是否被销毁
    重写__del__方法
"""

# 导入模块建议
"""
导入模块：
１．在导入模块是，建议按照以下顺序导入
    １．官方标准模块导入
    ２．第三方模块导入
    ３．应用程序模块导入

"""

# pygame精灵组常用方法
"""
__init__(self,*精灵):

add(*Sprites):向组中添加精灵

Sprites()：返回所有精灵列表

update(*args):让组中所有精灵调用update方法

draw(Surface):将组中所有精灵的　image,会知道Surface的rect位置

"""

# pygame精灵介绍
"""
需要派生子类
属性:
image 记录图像数据

rect　记录在屏幕上的位置

方法
update()　更新精灵位置

kill()　从所有组中删除
"""

