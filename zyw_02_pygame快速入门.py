# 目标
"""
1.项目准备
２．使用pygame创建图形窗口
３．理解　图像　并实现图像绘制
４．理解游戏循环和游戏时钟
５．理解精灵和精灵组
"""

# 项目准备
"""
１．新建飞机大战项目
２．新建一个zyw_01_pygame入门.py
３．导入游戏素材图片
游戏的第一印象：
    １．把一些静止的图像绘制到游戏窗口中
    ２．根据用户的交互或其他情况。移动这些图像，产生动画效果
    ３．根据图像之间是否发生重叠，判断　敌机是否被摧毁　等其他情况
"""

# 01.使用pygame创建图形窗口
"""
目标：
１．游戏的初始化，
２．理解游戏中的坐标系
３．创建游戏主窗口
４．简单的游戏循环
    可以将图片素材绘制到游戏的窗口上，开发游戏之间需要知道如何建立游戏窗口
"""

# 1.1游戏的初始化和退出
"""
要使用pygame提供的所有的功能，需要调用init方法
在游戏结束前要调用一下quit方法
方法              说明
pygame.init()       导入并初始化所有pygame模块，使用其他模块之前，必须先调用init方法
pygame.quit()       卸载所有pygame模块，在游戏结束之前调用
pygame.init() => 游戏代码　=> pygame.quit
"""

# 1.2理解游戏中的坐标系
"""
原点在左上角(0,0)
y轴　垂直方向向下，逐渐增加
x轴　水平方向向下，逐渐增加

在游戏中，所有可见的元素(小飞机)　都是以　　--矩形区域--　　来描述位置的
    要描述一个矩形区域有四个要素：
    （x,y）　　指定左上角位置
    (width,height)  　指定宽和高（大小）
pygame.Rect    
  pygame专门提供了一个类　pygame.Rect用于描述矩形区域
    Rect(x,y,width,height) -> Rect
  pygame.Rect类的详细属属性：
    x,y ||left,top,bottom,right ||center,centerx,centery ||size,width,height
        访问一个矩形对象的size属性时会返回一个元组（width,height）
提示：
 pygame.Rect是一个比较特殊的类，内部只是封装了一些数字计算
 不执行pygame.init()方法同样能够直接使用
 
导入图片：

"""

# 案例演练(Rect)
"""
需求：
１．定义一个hero_rect矩形标书英雄的位置和大小
２．输出英雄的坐标原点（x,y）
３．输出英雄的尺寸（宽度和高度）
"""

# 1.3创建游戏的主窗口
"""
pygame专门提供了一个模块pygame.display用于创建，管理游戏窗口
方法                          说明
pygame.display.set_mode()       初始化游戏显示窗口
pygame.display.update()         刷新屏幕内容显示，稍后使用

set_mode方法语法：
　   set_mode（resolution=(0,0),flags=0,depth=0) -> Surface（三个参数都有缺省值(参数)，默认都不需要创建。缺省值（参数有＝号（好像是）））
　作用：创建游戏显示窗口
　参数：
    resolution指定屏幕的宽和高，默认创建的窗口大小和屏幕大小一致
    flags参数指定屏幕的附加选项，例如是否全屏等等，默认不需要传递
    depth参数表示颜色的位数，默认自动匹配
　返回值：
    暂时可以理解为游戏的屏幕，游戏的元素都需要被绘制到游戏的屏幕上
注意：必须使用变量记录set_mode方法的返回结果！因为：后续所有图像都会基于这个返回结果（这个返回结果＝游戏的屏幕）  

"""

# 02理解图像并实现图像绘制
"""
在游戏中能够看到的游戏元素　大多都是图像
    图像文件初始是保存在磁盘上的，如果需要使用，第一步就需要被加载到内存
要在屏幕上看到某一个图像的内容，需要按照三个步骤：
    １．使用pygame.load()加载图像的数据
    ２．使用游戏屏幕对象，调用blit方法将图像绘制到指定位置
    ３．调用pygame.display.update()方法更新整个屏幕的显示
流程：
pygame.image.load(file_path) => pygame.sueface.blit(图像，位置)　=> pygame.diaplay.update()

提示：要想在屏幕上看到绘制的结果，就一定要调用pygame.display.update()方法

理解update（）方法的作用：
    可以在screen对象完成所有blit方法之后，
    统一调用一次　display.update方法，同样可以在屏幕上看到最终的绘制结果
　１．使用diaplay.set_mode()创建的screen对象是　一个内存中的　屏幕数据对象
    可以理解成油画的画布
　２．screen.blit方法可以在画布上绘制很多图像
    例如：英雄，敌机，子弹....
    这些图像有可能　会彼此重叠或者覆盖
　３．display.update()会将画布的最终结果绘制在屏幕上，
    　这样可以提高屏幕绘制效率，增加游戏的流畅度
    
透明图像：
    １．png格式的图像是支持透明的
    ２．在绘制图像时，透明区域不会显示任何内容
    ３．但是如果下方已经有内容，会透过透明区域显示出来  
"""

# 3.1游戏中的动画实现原理
"""
１．跟电影的原理类似，游戏中的动画效果，本质上是　快速的在屏幕上绘制图像
    电影是将多张　静止的电影胶片连续，快速的播放，产生连贯的视觉效果
２．一般在电脑上　每秒绘制60(60帧)，就能够达到非常　连续　高品质　的动画效果
    每次绘制的结果被称为帧Frame
    # 每一次调用update方法产生的结果我们叫做帧
"""

# 3.2游戏循环
"""游戏的两个组成部分
游戏循环的开始　就意味着　游戏的正式开始

游戏初始化         ||      　游戏循环

1.设置游戏窗口        ||      1.设置刷新频率

2.绘制图像初始位置     ||      2. 检测用户交互

3.设置游戏时钟        ||      3.更新所有图像位置
                            
                  ||    　  4. 更新屏幕显示
游戏循环的作用：
    １．保证游戏不会直接退出
    ２．变化图像位置　--动画效果
        每隔1/60秒移动一下所有图像的位置
        调用pygame.diaplay.update()更新屏幕显示
    ３．检测用户交互　--按键鼠标等

"""

# 3.3游戏时钟
"""
pygame 专门提供了一个类　pygame.time.Clock可以非常方便的设置屏幕绘制速度　--刷新率
要使用时钟对象　需要两步：
    １．在游戏初始化创建一个时钟对象
    ２．在游戏循环中让时钟对象调用tick(帧率)方法
tick方法会根据上次被调用的时间，自动设置　游戏循环　中的延时


"""

# 3.4英雄的简单动画实现
"""
1.在游戏初始化定义一个　pygame.Rect的变量记录英雄的初始位置
２．在游戏循环中每次让英雄的y-1　--向上移动
３．y <= 0将英雄移动到屏幕的底部
提示：每一次调用　update()方法之前，需要把所有的游戏图像都重新绘制一遍
    而且应该最先绘制背景图像
"""

# 3.5在游戏循环中监听事件
"""
事件event
  就是游戏启动后，用户针对游戏所做的操作
  例如：点击关闭按钮，点击鼠标，按下键盘
监听：
  在游戏循环中，判断用户　具体的操作
    只有捕获　到用户具体的操作，才能有针对性的做出响应
代码实现：
  pygame 中通过 pygame.event.get()可获得用户　当前所做动作　的事件　列表
    用户可以同一时间做很多事情
  
提示：关闭游戏代码
    这段代码非常的固定，几乎所有的pygame游戏都大同小异
＃　事件监听
for event in playgame.event.get():
    # 判断事件类型是否是退出事件（用户是否点击了关闭按钮）
    if event.type == pygame.QUIT：
        print("退出游戏")
        
        ＃　对所有的pygame的模块做一个卸载
        pygame.quit()
        
        # 直接退出系统
        exit()  
exit()  # 把当前正在执行的程序退出.
pygame.quit()  ＃ 对所有的pygame的模块做一个卸载
if   是判断语句，只判断一次，在循环中根据具体情况一次次判断
"""

# TODO libpng error  https://blog.csdn.net/icamera0/article/details/50843172
"""libpng warning: iCCP: known incorrect sRGB profile
不会造成影响，只会对后期调试影响，
原因是png文件在程序内运行格式错误，
想要解决　只需把文件重新转为image模式即可
"""












